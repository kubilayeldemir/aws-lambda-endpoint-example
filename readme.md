AWS Lambda REST Endpoint Example with Go using APIGatewayProxy or Function URL

```
curl -X POST https://your-api-gateway-endpoint/ \
-H "Content-Type: application/json" \
-d '{"name": "John Doe"}'
```

If you enabled FunctionUrl
visit `https://your-function-url-endpoint/?name=kubilay`

_**Disclaimer: This readme.md is generated by ChatGpt, ChatGPT can make mistakes. Consider checking important information.**_

### Step 1: Create an ECR repository (optional if already created)
aws ecr create-repository --repository-name my-app

### Step 2: Authenticate Docker client to ECR
aws ecr get-login-password --region us-west-2 | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-west-2.amazonaws.com

### Step 3: Build the Docker image
docker build -t my-app .

### Step 4: Tag the Docker image
docker tag my-app:latest 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app:latest

### Step 5: Push the Docker image to ECR
docker push 123456789012.dkr.ecr.us-west-2.amazonaws.com/my-app:latest

### Step 6: Create Lambda Set Image Add Trigger
Create lambda from AWS Console and select image you uploaded.
Add trigger: Api Gateway or create Function Url from Lambda -Configuration tab.

OR

Use AWS cli.
<details>
  <summary><i>I want to use AWS CLI</i></summary>

### Step 2: Create a Lambda Function with the Container Image

1. Create the Lambda function:
   ```sh
   aws lambda create-function \
       --function-name <function_name> \
       --code ImageUri=<aws_account_id>.dkr.ecr.<region>.amazonaws.com/<repository_name>:<tag> \
       --role <role_arn> \
       --package-type Image \
       --timeout 15 \
       --memory-size 512
   ```

Replace `<region>`, `<aws_account_id>`, `<repository_name>`, `<tag>`, `<function_name>`, and `<role_arn>` with your actual values.

### Step 2.5: Create the API Gateway

Before you can set up the API Gateway trigger in Step 3, you need to create an API Gateway. Here's how you would do it using the AWS CLI:

1. Create a new REST API (for example):
   ```sh
   aws apigateway create-rest-api --name '<api_name>'
   ```
   This command will output an API ID, which you'll use in subsequent steps.

2. Get the root resource ID of the API:
   ```sh
   aws apigateway get-resources --rest-api-id <api_id>
   ```
   Look for the `id` of the root resource, typically represented as `/`.

3. Create a new resource (if needed):
   ```sh
   aws apigateway create-resource \
       --rest-api-id <api_id> \
       --parent-id <root_resource_id> \
       --path-part <resource_name>
   ```
   The resource corresponds to an endpoint or path in your API, like `/users` or `/products`.

4. Define a new method on the resource that will trigger your Lambda function:
   ```sh
   aws apigateway put-method \
       --rest-api-id <api_id> \
       --resource-id <resource_id> \
       --http-method POST \
       --authorization-type NONE
   ```

5. Set up integration between the method and the Lambda function:
   ```sh
   aws apigateway put-integration \
       --rest-api-id <api_id> \
       --resource-id <resource_id> \
       --http-method POST \
       --type AWS_PROXY \
       --integration-http-method POST \
       --uri arn:aws:apigateway:<region>:lambda:path/2015-03-31/functions/<function_arn>/invocations
   ```
   The `--uri` parameter specifies the ARN of your Lambda function.

Now you can proceed with the original Step 3: Set Up the API Gateway Trigger, where you grant the API Gateway permission to invoke your Lambda function and deploy the API to make it accessible. Remember to replace placeholders with your actual values for API names, IDs, ARNs, etc.

### Step 3: Set Up the API Gateway Trigger

1. Grant the API Gateway permission to invoke your Lambda function:
   ```sh
   aws lambda add-permission \
       --function-name <function_name> \
       --statement-id apigateway-test-123 \
       --action lambda:InvokeFunction \
       --principal apigateway.amazonaws.com \
       --source-arn <arn_of_api_gateway_resource>
   ```

2. Deploy the API Gateway to make it accessible:
   ```sh
   aws apigateway create-deployment \
       --rest-api-id <api_id> \
       --stage-name <stage_name>
   ```

Replace `<api_id>`, `<stage_name>`, and `<arn_of_api_gateway_resource>` with the appropriate values for your API Gateway setup.

### Step 4: Configure the Lambda Function URL

Starting from AWS CLI version 2.1.30, you can use the `create-function-url-config` command to create a Function URL.

1. Create a Lambda Function URL:
   ```sh
   aws lambda create-function-url-config \
       --function-name <function_name> \
       --auth-type NONE
   ```

For `--auth-type`, you can specify `NONE` for no authentication or `AWS_IAM` to use AWS IAM permissions for authentication.

After performing these steps, you'll have a Lambda function created from a container image, with an API Gateway set up as a trigger and a Lambda Function URL for direct HTTP invocations.

**Note:** Replace the placeholder values with your actual values for function names, ARNs, etc. Additionally, ensure that the AWS CLI is installed and configured with the appropriate permissions to create and manage Lambda functions and API Gateway resources.

</details>

# AWS Lambda Invocation Options

AWS Lambda supports various methods of invocation, with two primary options for triggering functions over the internet: Lambda Function URLs and API Gateway Proxy Integration.

## Lambda Function URLs

Lambda Function URLs provide a straightforward approach to invoke your Lambda function with an HTTPS endpoint directly managed by AWS.

### Features of Lambda Function URLs

- **Simplicity**: Easily create an HTTPS endpoint without the complex configuration required by API Gateway.
- **Direct Invocation**: Trigger your Lambda function directly using the provided URL.
- **Authentication**: Supports CORS configuration and basic authentication options, including AWS_IAM and public access.

### Considerations

- Does not include advanced API Gateway features such as request validation, throttling, caching, or custom authorizers.
- Not suited for scenarios that require custom domain names or API stages.

### Ideal Use Cases

- Handling webhooks from services like GitHub or Stripe.
- Creating simple, single-purpose HTTP APIs.
- Rapid prototyping where advanced features are not necessary.

## API Gateway Proxy Integration

API Gateway is a full-featured service that provides more control and features for creating and managing HTTP endpoints for Lambda functions.

### Features of API Gateway

- **Comprehensive Toolset**: Offers request/response transformations, security policies, rate limiting, and other API management features.
- **Stages and Versions**: Allows the use of multiple stages (such as development, staging, and production) and supports version control.
- **Custom Domain Names**: Supports the assignment of custom domain names to your APIs.
- **Diverse Integrations**: Facilitates a range of integration options with Lambda, other HTTP endpoints, AWS services, or VPC Links.

### Ideal Use Cases

- Developing RESTful APIs with complex requirements.
- APIs that need strict management, authorization, and control over requests and responses.
- Applications that require API usage plans and key management for controlled access.

## Conclusion

Lambda Function URLs are best for simple and quick HTTP(S) endpoint needs. For more advanced requirements and professional API management, API Gateway is the recommended approach.

Choose the right tool based on your application's specific needs and the features you require.

---

For more information, visit the [AWS Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html) and the [Amazon API Gateway Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html).

# What are the advantages of using lambda for an endpoint?

Using AWS Lambda for endpoint services comes with a variety of advantages, especially when dealing with microservices, serverless architectures, or event-driven systems. Here are some of the key benefits:

1. **Serverless Execution**: Lambda functions are serverless, meaning you don't have to provision or manage servers. You simply write code and upload it to Lambda, which runs it on high-availability compute infrastructure.

2. **Auto-Scaling**: Lambda automatically scales your application by running code in response to each trigger. Your code runs in parallel and processes each trigger individually, scaling precisely with the size of the workload, from a few requests per day to thousands per second.

3. **Pay-Per-Use**: With Lambda, you are charged based on the number of requests for your functions and the time your code executes. This can be more cost-effective compared to paying for idle compute resources.

4. **Zero Administration**: Deploy your code to Lambda and it takes care of everything required to run and scale your code with high availability. You can set up your code to automatically trigger from other AWS services or call it directly from any web or mobile app.

5. **Integrated Security**: Lambda integrates with AWS IAM, allowing you to establish permissions for your Lambda functions at a granular level. It also integrates with AWS Key Management Service (KMS) for managing keys used to encrypt/decrypt sensitive data.

6. **Performance**: You can optimize execution time by choosing the right memory size for your function. Plus, with provisioned concurrency, you can ensure that your function responds quickly even after periods of inactivity.

7. **Continuous Scaling**: As your application usage grows, your Lambda functions can scale to meet demand without any additional configuration.

8. **Flexible Resource Model**: You can choose the amount of memory that's allocated to your functions, which also proportionally allocates CPU and other resources.

9. **Event-Driven**: Lambda can be triggered by a variety of AWS services (like S3, DynamoDB, Kinesis, SNS, and SQS), enabling you to build complex, real-time, responsive systems.

10. **Version Control and Alias**: AWS Lambda maintains your function's versions and allows you to use aliases to manage environments (like prod, dev, or test), which can be very helpful for CI/CD practices.

11. **Integrated Monitoring**: AWS Lambda integrates with CloudWatch and X-Ray, providing you with metrics, logging, and tracing capabilities.

12. **Built-in Fault Tolerance**: Lambda maintains compute capacity across multiple Availability Zones in each region to help protect your code against individual machine or data center facility failures.

13. **Environment Variables**: Lambda allows you to use environment variables to adjust your function's behavior without making changes to your code.

14. **Language Support**: Lambda supports multiple programming languages, which gives you the flexibility to write functions in the language you are most comfortable with or which best suits the task.

15. **Extensions and Layers**: Lambda extensions and layers allow you to use libraries and software dependencies without having to include them in your deployment package, making it easier to manage your deployment artifacts.

16. **Concurrency Controls**: You have control over the level of concurrency that your function can reach, allowing you to reserve capacity or set a maximum level of concurrency for a function.

By using Lambda for endpoints, you get the benefits of reduced operational overhead, cost savings from the pay-per-use model, and built-in scalability and reliability, all of which can significantly speed up the development, deployment, and management process of your applications.


## Request Model Of Lambda Proxy Integration
When you're using the Lambda proxy integration feature in Amazon API Gateway, the API Gateway service transforms the incoming HTTP request into a standard format before passing it on to the Lambda function. This standardized format includes all the necessary data that the function needs to process the request.

If you are going to use the functionURL instead of api gateway, use events.LambdaFunctionURLRequest as request model.
There are some differences. For example: LambdaFunctionURLRequest do not have HTTPMethod variable since it's a URL.

Here's the basic structure of the event object that the Lambda function receives:

```json
{
    "resource": "Resource path",
    "path": "Path parameter",
    "httpMethod": "Incoming request's method name",
    "headers": {String containing incoming request headers},
    "multiValueHeaders": {List of strings containing incoming request headers},
    "queryStringParameters": {Query string parameters},
    "multiValueQueryStringParameters": {List of query string parameters},
    "pathParameters":  {Path parameters},
    "stageVariables": {Applicable stage variables},
    "requestContext": {
        "resourceId": "Id generated by API Gateway",
        "resourcePath": "Path defined in API Gateway",
        "httpMethod": "Incoming request's method name",
        "extendedRequestId": "Id generated by API Gateway",
        "requestTime": "The request time with a format of dd/Mon/yyyy:HH:mm:ss Z",
        "path": "Path parameter",
        "accountId": "AWS account ID associated with the request",
        "protocol": "Request protocol",
        "stage": "Stage of the API Gateway",
        "domainPrefix": "Domain prefix",
        "requestTimeEpoch": "The request time in epoch milliseconds",
        "requestId": "Id generated by API Gateway for the request",
        "identity": {
            "cognitoIdentityPoolId": "Pool ID",
            "accountId": "Account ID",
            "cognitoIdentityId": "ID of the Amazon Cognito Identity",
            "caller": "Caller",
            "sourceIp": "Source IP",
            "principalOrgId": "If the API is made by an org, this is the ID of the org",
            "accessKey": "Access key",
            "cognitoAuthenticationType": "Authentication type",
            "cognitoAuthenticationProvider": "Authentication provider",
            "userArn": "User ARN",
            "userAgent": "User agent",
            "user": "User"
        },
        "domainName": "API Gateway domain name",
        "apiId": "API ID"
    },
    "body": "A JSON string of the request payload.",
    "isBase64Encoded": false | true
}
```

**Key Elements:**

- **resource and path**: These are the URI path and resource path of the endpoint.
- **httpMethod**: The HTTP method used (GET, POST, etc.).
- **headers and multiValueHeaders**: The headers that are sent with the request. `multiValueHeaders` includes headers that have multiple values.
- **queryStringParameters and multiValueQueryStringParameters**: Any query string parameters included in the request. `multiValueQueryStringParameters` includes query parameters that have multiple values.
- **pathParameters**: Path parameters that you've defined in your resource path.
- **stageVariables**: Environment-specific variables you've set up on your API Gateway stage.
- **requestContext**: Contains additional context about the request, such as the identity of the caller, the API Gateway stage, and a unique request identifier.
- **body**: The payload of the request. For a typical JSON payload, you would parse this JSON into an object.
- **isBase64Encoded**: A boolean flag to indicate if the applicable request payload is Base64-encode

## Response Model Of Lambda Proxy Integration
When using AWS API Gateway with the Lambda Proxy Integration, the expected format for the Lambda function to return a response that API Gateway can understand and transform into an HTTP response is as follows:

```json
{
    "isBase64Encoded": boolean, // true or false
    "statusCode": httpStatusCode, // a valid HTTP status code
    "headers": { // a map of string to strings for the HTTP response headers
        "HeaderName": "HeaderValue",
        ...
    },
    "body": "..." // a string representation of the response body
}
```

Here's a detailed explanation of each field:

- `isBase64Encoded`: This is a boolean field that should be `true` if the `body` is Base64-encoded (for binary data), or `false` otherwise (for text data).

- `statusCode`: This must be a valid HTTP status code as an integer (e.g., `200`, `400`, `500`).

- `headers`: This is an object containing key-value pairs, where the key is the name of the header (e.g., `"Content-Type"`) and the value is the value of the header (e.g., `"application/json"`). These headers are included in the response sent back to the client.

- `body`: This is the body of the response. It must be a string. If `isBase64Encoded` is `true`, this should be a Base64-encoded string representing binary data. If `isBase64Encoded` is `false`, it should be a regular string.

For example, if your Lambda function is returning JSON, you need to convert the JSON object to a string before setting it in the `body` field. Here is how your Go Lambda function might format a response:

```go
type Response events.APIGatewayProxyResponse

func HandleRequest(ctx context.Context, request events.APIGatewayProxyRequest) (Response, error) {
    // ... your logic here ...

    // Create a response object.
    responseBody, err := json.Marshal(yourObject)
    if err != nil {
        return Response{StatusCode: 500}, err
    }

    // Return the response in the expected format.
    return Response{
        StatusCode: 200,
        Headers:    map[string]string{"Content-Type": "application/json"},
        Body:       string(responseBody),
        // If you're returning binary data, set isBase64Encoded to true
        // and ensure the body is base64 encoded string.
        IsBase64Encoded: false,
    }, nil
}
```

Make sure you serialize your response body as a JSON string because the `body` field expects a string, not an object. If you return an object directly, it will not be properly handled by API Gateway and could result in an error like a `502 Bad Gateway` response.


